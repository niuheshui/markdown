# leetcode 题解

### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

C++:

``` c++
class Solution {
public:
	// 双指针
	int removeDuplicates(vector<int>& nums) {        
		int l = 0, r = 1;      
		int n = nums.size();        
		while (r < n) { 
            // l 指向待插入位置的前一个元素
			if (nums[r] != nums[l]) {  
				nums[++l] = nums[r];            
			}           	
			r++;       
		}       
		return l + 1;    
	}
};
```

```c++
class Solution {
public:
    // 更加通用的解法
    int removeDuplicates(vector<int>& nums) {
        return process(nums, 1);
    }
    
    // k 表示最多保留k位
    int process(vector<int>& nums, int k) {
        int n = nums.size();
        int idx = 0;
        for (int x : nums) {
            // idx 指向待插入位置
            if (idx < k || nums[idx - k] != x)
                nums[idx++] = x;
        }
        
        return idx;
    }
};
```

Java:

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        int l = 0, r = 1;
        while (r < n) {
            if (nums[l] != nums[r]) {
                nums[++l] = nums[r];
            }
            r++;
        }
        return l + 1;
    }
}
```

Python:

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        n = len(nums)
        l, r = 0, 1
        while r < n:
            if nums[l] != nums[r]:
                nums[l + 1] = nums[r]
                l += 1
            r += 1
        return l + 1
```

### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

C++:

```c++
class Solution {
public:
    // 动态规划
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        // dp[0][i] 第i天交易结束后手里有股票
        // dp[1][i] 第i天交易结束后手里没有股票
        vector<vector<int>> dp(2, vector<int>(n, 0));
        // 初始化第一天买股票
        dp[0][0] = -prices[0];
        for (int i = 1; i < n; i++) {
            // 在卖出股票所获得的最大利润的基础上买或保持前一天所获得的利润
            dp[0][i] = max(dp[0][i - 1], dp[1][i - 1] - prices[i]);
            // 在前一天买入的基础上卖出或保持前一天的状态
            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i]);
        }
        
        return dp[1][n - 1];
    }
};
```

```c++
class Solution {
public:
    // 动态规划 优化
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        // 因为只与前一天的状态有关 所以可以使用一个变量来表示
        int pre0 = -prices[0], pre1 = 0;
        // pre0 第i天交易结束后手里有股票
        // pre1 第i天交易结束后手里没有股票
        for (int i = 1; i < n; i++) {
            // 在卖出股票所获得的最大利润的基础上买或保持前一天所获得的利润
            pre0 = max(pre0, pre1 - prices[i]);
            // 在前一天买入的基础上卖出或保持前一天的情况
            pre1 = max(pre1, pre0 + prices[i]);
        }
        
        return pre1;
    }
};
```

```c++
class Solution {
public:
    /*
    	贪心
    	保证在最低点买入最高点卖出 <==> 后一天价格比前一天高 前一天买后一天卖
    */
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int res = 0;
        for (int i = 0; i < n - 1; i++) {
            if (prices[i] < prices[i + 1])
                res += prices[i + 1] - prices[i];
        }
        return res;
    }
};
```

Java:

```java
class Solution {
    // 动态规划
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int pre0 = -prices[0], pre1 = 0;
        for (int i = 1; i < n; i++) {
            pre0 = Math.max(pre0, pre1 - prices[i]);
            pre1 = Math.max(pre1, pre0 + prices[i]);
        }
        return pre1;
    }
}
```



```java
class Solution {
    // 贪心
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int res = 0;
        for (int i = 0; i < n - 1; i++) {
            if (prices[i] < prices[i + 1])
                res += prices[i + 1] - prices[i];
        }
        return res;
    }
}
```



### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

C++:

```c++
class Solution {
public:
    // 将[l, r]内的内容翻转
    void reverse(vector<int>& nums, int l, int r) {
        while (l < r) 
            swap(nums[l++], nums[r--]);
    }
    
    // 三次翻转
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k %= n;
        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }
};
```

Java:

```java
class Solution {
    
    private void reverse(int[] arr, int l, int r) {
        while (l < r) {
            int tmp = arr[l];
            arr[l] = arr[r];
            arr[r] = tmp;
            l++; r--;
        }
    }
    
    public void rotate(int[] nums, int k) {       
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);        
    }
}
```



### [852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

Java:

```java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        // 二分查找位置
        int l = 0, r = arr.length - 1;
        while (l < r) {
            int mid = (l + r) / 2;
            if (arr[mid] < arr[mid + 1]) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        
        return r;
    }
}
```

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

Java:

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 滑动窗口
        if (s.length() == 0)
            return 0;
        HashMap<Character, Integer> map = new HashMap<>();
        int l = 0, r = 0, ans = -1;
        while (r < s.length()) {
            if (map.containsKey(s.charAt(r))) {
                l = Math.max(l, map.get(s.charAt(r)) + 1);
            }
            map.put(s.charAt(r), r);
            ans = Math.max(ans, r - l + 1);
            r++;
        }
        return ans;
    }
}
```

### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

Java:

```java
class Solution {
    // 中心扩展算法
    private int[] check(String s, int l, int r) {
        while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
            l--;
            r++;
        }
        return new int[] {l + 1, r - 1};
    }

    public String longestPalindrome(String s) {
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int[] a = check(s, i, i); // 奇数个
            int[] b = check(s, i, i + 1); // 偶数个

            if (a[1] - a[0] > end - start) {
                start = a[0];
                end = a[1];
            }

            if (b[1] - b[0] > end - start) {
                start = b[0];
                end = b[1];
            }
        }
        return s.substring(start, end + 1);
    }
}
```

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

Java:

```java
class Solution {
    // 哈希
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> mp = new HashMap<>();
        for (int i = 0; i < nums.length(); i++) {
            int x = target - nums[i];
            if (mp.containsKey(x)) {
                return new int[] {mp.get(x), i};
            }
            mp.put(nums[i], i);
        }
        return null;
    }
}
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

Java:

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // 哈希表 使用排序后的字符串作为键
        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs) {
            char[] array = str.toCharArray();
            Arrays.sort(array);
            String key = new String(array);
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(str);
            map.put(key, list);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```

### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

Java:

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> num_set = new HashSet<>();
        // 去重
        for (int num : nums) {
            num_set.add(num);
        }
        
        int ans = 0;
        
        for (int num : num_set) {
            // 只从连续序列的最左端开始
            if (!num_set.contains(num - 1)) {
                int cur = num; 
                int tmp = 1;
                while (num_set.contains(cur + 1)) {
                    // 连续个数
                    cur += 1;
                    tmp += 1;
                }
                // 更新答案
                ans = Math.max(ans, tmp);
            }
        }
        
        return ans;
    }
}
```

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

Java:

```java
class Solution {
    public void moveZeroes(int[] nums) {
        // 双指针 l待插入位置 r非零插入到l移动指针
        int l = 0, r = 0;
        while (r < nums.length) {
            if (nums[r] != 0) {
                int tmp = nums[l];
                nums[l] = nums[r];
                nums[r] = tmp;
                l++;
            }          
            r++;
        } 
    }
}
```

### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

Java:

```java
class Solution {
    public int maxArea(int[] height) {
        /*
        	双指针
        	初始化从最长边界开始
        	向内移动短板
        	不断更新答案
        */
        int n = height.length;
        int ans = 0;
        int l = 0, r = n - 1; 
        while (l < r) {
            ans = Math.max(ans, Math.min(height[l], height[r]) * (r - l));
            if (height[l] < height[r])
                l++;
            else 
                r--; 
        }
        return ans;
    }
}
```

### [15. 三数之和](https://leetcode.cn/problems/3sum/)

Java:

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        // 枚举 a
        for (int i = 0; i < n; ++i) {
            // 需要和上一次枚举的数不相同
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            int r = n - 1;
            int target = -nums[i];
            // 枚举 b
            for (int l = i + 1; l < n; ++l) {
                // 需要和上一次枚举的数不相同
                if (l > i + 1 && nums[l] == nums[l - 1]) {
                    continue;
                }
                // 需要保证 b 的指针在 c 的指针的左侧
                while (l < r && nums[l] + nums[r] > target) {
                    --r;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if (l == r) {
                    break;
                }
                if (nums[l] + nums[r] == target) {
                    List<Integer> list = new ArrayList<Integer>();
                    list.add(nums[i]);
                    list.add(nums[l]);
                    list.add(nums[r]);
                    ans.add(list);
                }
            }
        }
        return ans;
    }
}

```

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

Java:

```java
class Solution {
    public int trap(int[] height) {
        // 栈
        int sum = 0;
        Stack<Integer> stack = new Stack<>();
        int current = 0;
        while (current < height.length) {
            // 栈不为空且当前高度比栈顶大
            while (!stack.empty() && height[current] > height[stack.peek()]) {
                int h = height[stack.peek()];
                stack.pop();
                if (stack.empty()) {
                    break;
                }
                // 求出current和栈顶之间的水
                int distance = current - stack.peek() - 1;
                int min = Math.min(height[stack.peek()], height[current]);
                sum += distance * (min - h);
            }
            stack.push(current);
            current++;
        }
        return sum;
    }
}
```

### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

Java:

```java
class Solution {
    
    
    private boolean comp(int[] a, int[] b) {
        if (a.length != b.length)
            return false;
        
        for (int i = 0; i < a.length; i++)
            if (a[i] != b[i])
                return false;
    
        return true;
    }
    
    
    public List<Integer> findAnagrams(String s, String p) {
        // 滑动窗口
        List<Integer> ans = new ArrayList<>();
        
        if (s.length() < p.length())
            return ans;
        
        int[] a = new int[26]; // p中每个字符的个数
        int[] b = new int[26]; // 当前窗口s中每个字符个数
        
        for (int i = 0; i < p.length(); i++) {
            a[p.charAt(i) - 'a']++;
            b[s.charAt(i) - 'a']++;
        }
        if (comp(a, b)) {
            ans.add(0);
        }
        
        for (int i = 1; i <= s.length() - p.length(); i++) {
            b[s.charAt(i - 1) - 'a']--;
            b[s.charAt(i + p.length() - 1) - 'a']++;
            if (comp(a, b)) {
                ans.add(i);
            }
        }
        
        return ans;
        
    }
}
```

### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

Java:

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        /*
        	哈希表
        	符合条件的子数组一定满足[i, j]
        	pre[j] = pre[i] - k 
        */
        int count = 0;
        int pre = 0;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        
        
        for (int i = 0; i < nums.length; i++) {
            pre += nums[i];
            if (map.containsKey(pre - k)) {
                count += map.get(pre - k);
            }
            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }
        
        return count;
    }
}
```

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

Java:

```java
class Solution {
    public int maxSubArray(int[] nums) {
 		/*
 			动态规划
 			pre 目前为止最大和
 			ans 记录最大值返回
 		*/       
        int pre = nums[0];
        int ans = pre;
        for (int i = 1; i < nums.length; i++) {
            pre = Math.max(pre + nums[i], nums[i]);
            ans = Math.max(pre, ans);
        }
        
        return ans;
    }
}
```

### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

Java:

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        
        if (intervals.length == 0)
            return new int[0][2];
        // 按左区间进行排序 逐个合并
        Arrays.sort(intervals, (int[] a, int[] b) -> a[0] - b[0]);
        
        List<int[]> merged = new ArrayList<>();
        for (int i = 0; i < intervals.length; i++) {
            int l = intervals[i][0], r = intervals[i][1];
            if (merged.size() == 0 || merged.get(merged.size() - 1)[1] < l) {
                merged.add(new int[] {l, r});
            } else {
                merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], r);
            }
        }
        return merged.toArray(new int[0][]);
    }
}
```

### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

Java:

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        // 当前位置的左侧所有乘积
        ans[0] = 1;
        for (int i = 1; i < n; i++) {
            ans[i] = nums[i - 1] * ans[i - 1];
        }
        // r记录右侧所有乘积
        int r = 1;
        for (int i = n - 1; i >= 0; i--) {
            ans[i] *= r;
            r = nums[i] * r;
        }
          
        return ans;  
    }
}
```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

Java:

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        
        List<Integer> ans = new ArrayList<>();
        boolean[][] vis = new boolean[m][n]; // 标记是否走过
        
        int x = 0, y = 0, tot = 1; // 循环次数
        ans.add(matrix[x][y]);
        vis[x][y] = true;
        while (tot < m * n) {
            // 右
            while (y + 1 < n && !vis[x][y + 1]) {
                ans.add(matrix[x][++y]);
                vis[x][y] = true;
                tot++;
            }
            // 下
            while (x + 1 < m && !vis[x + 1][y]) {
                ans.add(matrix[++x][y]);
                vis[x][y] = true;
                tot++;
            }
            // 左
            while (y - 1 >= 0 && !vis[x][y - 1]) {     
                ans.add(matrix[x][--y]);
                vis[x][y] = true;
                tot++;
            }
            // 上
            while (x - 1 >= 0 && !vis[x - 1][y]) {
                ans.add(matrix[--x][y]);
                vis[x][y] = true;
                tot++;
            }  
        }
    
        return ans;   
    }
}
```

### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

Java:

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 沿对角线翻转
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = tmp;
            }
        }
        
        // 水平翻转
        for (int i = 0; i < n; i++) {
            int l = 0, r = n - 1;
            while (l < r) {
                int tmp = matrix[i][l];
                matrix[i][l] = matrix[i][r];
                matrix[i][r] = tmp;
                l++; r--;
            }
        } 
    }
}
```

### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

Java:

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        
        // 以(x,y)为右上角的矩阵
        int x = 0, y = n - 1;
        while (x < m && y >= 0) {
            if (matrix[x][y] == target) 
                return true;
            
            if (matrix[x][y] > target)
                y--;
            else
                x++;
        }
        return false;
    }
}
```

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

Java:

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null)
            return null;
        
        ListNode a = headA;
        ListNode b = headB;
        /*
        	A和B不相同的部分分别有a个和b个,相同的有c个
        	1. a == b
        		同时到达相同的
        	2. a != b
        		pa走完到null去headB 到达相交的节点需要走a+c+b
        		pb走完到null去headA 到达相交的节点需要走b+c+a
        */
        while (a != b) {
            a = (a == null) ? headB : a.next;
            b = (b == null) ? headA : b.next;
        }
        
        return a;
    }
}
```

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

Java:

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null)
            return head;
        // 获取新的头节点
        ListNode newH = reverseList(head.next);
        // 更改链表方向
        head.next.next = head;
        head.next = null;
        return newH;
    }
}
```

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

Java:

```java
class Solution {
    // 遍历链表复制到数组 使用数组判断是否是回文
    private boolean check(Integer[] arr) {
        int l = 0, r = arr.length - 1;
        while (l < r && arr[l] == arr[r]) {
            l++;
            r--;
        };
        return l >= r;
    }
    
    public boolean isPalindrome(ListNode head) {
        ArrayList<Integer> arr = new ArrayList<>();
        
        while (head != null) {
            arr.add(head.val);
            head = head.next;
        }
        
        return check(arr.toArray(new Integer[1])); 
    }
}
```

```java
class Solution {
   	// 递归
    private ListNode front;
    
    private boolean check(ListNode cur) {
        if (cur != null) {
            if (!check(cur.next))
                return false;
            if (front.val != cur.val)
                return false;
            front = front.next;
        }
        
        return true;
    }
    
    public boolean isPalindrome(ListNode head) {
        front = head;
        return check(head);
    }
}
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

Java:

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        // 快慢指针
        if (head == null || head.next == null)
                return false;  
        ListNode kuai = head.next, man = head;  
        while (man != kuai) {      
            if (kuai == null || kuai.next == null)
                return false; 
            man = man.next;
            kuai = kuai.next.next; 
        }       
        return true; 
    }
}
```

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        // 哈希
        HashSet<ListNode> set = new HashSet<>();    
        while (head != null) {
            if (!set.add(head)) 
                return true;
            head = head.next;
        }
        return false;    
    }
}
```

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

Java:

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 哈希
        HashSet<ListNode> set = new HashSet<>();
        while (head != null) {
            if (!set.add(head))
                return head;
            head = head.next;
        }
        return null;
    }
}
```

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 快慢指针
        if (head == null)
            return null;
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            if (fast.next != null) {
                fast = fast.next.next;
            } else {
                return null;
            }
            
            if (fast == slow) {
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null;
    }
}
```

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

Java:

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 迭代
        ListNode head = new ListNode();
        ListNode p = head;
        while (list1 != null && list2 != null) {          
            if (list1.val < list2.val) {
                p.next = list1;
                list1 = list1.next;
            } else {
                p.next = list2;
                list2 = list2.next;
            }            
            p = p.next;          
        }     
        p.next = list1 == null ? list2 : list1;     
        return head.next;      
    }
}
```

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 递归
        if (list1 == null || list2 == null)
            return list1 == null ? list2 : list1;
        if (list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        } else {
            list2.next = mergeTwoLists(list1, list2.next);
            return list2;
        }
    }
}
```

### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

Java:

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode pre = new ListNode(0);
        ListNode head = pre;
        int t = 0;
        while (l1 != null || l2 != null || t != 0) {
            if (l1 != null) {
                t += l1.val;
                l1 = l1.next;
            }
            if (l2 != null) {
                t += l2.val;
                l2 = l2.next;
            }
            ListNode p = new ListNode(t % 10);
            t /= 10;
            pre.next = p;
            pre = p;
        }
        return head.next;
    }
}
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

Java:

```java
class Solution {
    // 递归
    private int count = 1;
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if (head != null) {
            head.next = removeNthFromEnd(head.next, n);
            if (count++ == n)
                return head.next; 
            return head;
        }
        return null;        
    }
}
```

```java
class Solution {
    // 双指针 p1 p2 之间保持n的距离 p2到达最后一个时 p1指向倒数第n个节点的前驱
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode p = new ListNode(0, head);
        ListNode p1 = p, p2 = p;
        for (int i = 0; i < n; i++)
            p2 = p2.next;        
        while (p2.next != null) {
            p1 = p1.next;
            p2 = p2.next;
        }   
        p1.next = p1.next.next;       
        return p.next;       
    }
}
```

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

Java:

```java
class Solution {
    // 递归
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null)
            return head;
        ListNode newH = head.next;
        head.next = swapPairs(newH.next);
        newH.next = head;
        return newH;
    }
}
```

### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

Java:

```java
class Solution { 
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode h = new ListNode(0, head);  
        ListNode start = h.next; // 一组的头
        ListNode end = h; // 一组的尾
        boolean flag = false;        
        for (int i = 0; i < k; i++) {
            if (end == null) {
                flag = true;
                break;
            }
            end = end.next; // 找到一组末尾那个节点
        }        
        if (flag || end == null) // 找不到k个一组时原样返回
            return h.next;       
        ListNode nexth = reverseKGroup(end.next, k); // 下一组反转后的头
        // 将当前组反转
        end.next = null;
        h.next = reverseList(start);
        start.next = nexth; // 下一组反转后的头接上
        return h.next;
    }
    
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null)
            return head;
        ListNode newH = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newH;
    }   
}
```

### [138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)

Java:

```java
class Solution {
    // 哈希 如果没有就先创建 存入hash表中
    private HashMap<Node, Node> map = new HashMap<>();  
    public Node copyRandomList(Node h) {
        if (h == null)
            return null;
        if (!map.containsKey(h)) {
            Node _h = new Node(h.val);
            map.put(h, _h);
            _h.next = copyRandomList(h.next);
            _h.random = copyRandomList(h.random);
        }
        return map.get(h);
    }
}
```

### [148. 排序链表](https://leetcode.cn/problems/sort-list/)

Java:

```java
class Solution {
    // 归并排序
    private ListNode sort(ListNode h) {
        if (h == null || h.next == null)
            return h;
        // 中点
        ListNode p1 = h, p2 = h.next;
        while (p2 != null && p2.next != null) {
            p1 = p1.next;
            p2 = p2.next.next;
        }
        // 分治
        p2 = p1.next;
        p1.next = null;
        ListNode h1 = sort(h);
        ListNode h2 = sort(p2);
        // 合并
        return merge(h1, h2);
    }
    
    private ListNode merge(ListNode h1, ListNode h2) {   
        if (h1 == null || h2 == null) {
            return h1 == null ? h2 : h1;
        } else if (h1.val < h2.val) {
            h1.next = merge(h1.next, h2);
            return h1;
        } else {
            h2.next = merge(h1, h2.next);
            return h2;
        } 
    }
    
    public ListNode sortList(ListNode head) {
        return sort(head);
    }
}
```

### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

Java:

```java
class Solution {
    // 归并
    private ListNode mergeTwoList(ListNode h1, ListNode h2) {   
        if (h1 == null || h2 == null) {
            return h1 == null ? h2 : h1;
        }
        if (h1.val < h2.val) {
            h1.next = mergeTwoList(h1.next, h2);
            return h1;
        } else {
            h2.next = mergeTwoList(h1, h2.next);
            return h2;
        } 
    }
    
    private ListNode merge(ListNode[] lists, int l, int r) {
        if (l == r)
            return lists[l];
        if (l > r)
            return null;
        
        int mid = (l + r) >> 1;
        return mergeTwoList(merge(lists, l, mid), merge(lists, mid + 1, r));
    } 
    
    public ListNode mergeKLists(ListNode[] lists) {
        
       return merge(lists, 0, lists.length - 1);
    }
}
```

### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

Java:

```java
class LRUCache {
    // 哈希表 + 双向链表
    private class Node {
        int key;
        int val;
        Node prev;
        Node next;
        
        Node() {}
       
        Node(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }
    
    private HashMap<Integer, Node> cache = new HashMap<>();
    private int size;
    private int capacity;
    private Node head, tail;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        moveToHead(node);
        return node.val;
    }
    
    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node == null) {
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addToHead(newNode);
            size++;
            if (size > capacity) {
                Node delNode = removeTail();
                cache.remove(delNode.key);
                size--;
            }
        } else {
            node.val = value;
            moveToHead(node);
        }
    }
    
    private void addToHead(Node node) {
       	node.next = head.next;  
        node.prev = head;
        head.next.prev = node;
        head.next = node;
    }
    
    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }
    
    private Node removeTail() {
        Node res = tail.prev;
        removeNode(res);
        return res;
    }
}
```

### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

Java:

```java
class Solution {
    // 递归
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        inorderTraversal(root, ans);
        return ans;
    }
    
    private void inorderTraversal(TreeNode root, List<Integer> ans) {
        if (root != null) {
            inorderTraversal(root.left, ans);
            ans.add(root.val);
            inorderTraversal(root.right, ans);
        }
    }
}
```

```java
class Solution {
    // 迭代
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        Deque<TreeNode> stk = new LinkedList<>();
        while (root != null || !stk.isEmpty()) {
            while (root != null) {
                stk.push(root);
                root = root.left;
            }
            root = stk.pop();
            ans.add(root.val);
            root = root.right;
        }
        return ans;
    }  
}
```

### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

Java:

```java
class Solution {
    // 递归
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

Java:

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root != null) {
            TreeNode l = invertTree(root.left);
            TreeNode r = invertTree(root.right);
            root.left = r;
            root.right = l;
        }        
        return root;
    }
}
```

### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

Java:

```java
class Solution {
    private boolean check(TreeNode l, TreeNode r) {
        if (l == null && r == null)
            return true;
        if (l == null || r == null)
            return false;
        return l.val == r.val && check(l.left, r.right) && check(l.right, r.left);    
    }
    
    public boolean isSymmetric(TreeNode root) {
        return check(root, root); 
    }
}
```

### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

Java:

```java
class Solution {
    // 丑陋的代码
    private HashMap<TreeNode, Integer> cache = new HashMap<>();
    private int hight(TreeNode root) {
        if (root == null)
            return 0;
        Integer ans = cache.get(root);
        if (ans == null) {
            cache.put(root, Math.max(hight(root.left), hight(root.right)) + 1);
        } 
        return cache.get(root);
    }
    
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null)
            return 0;
        return Math.max(
            hight(root.left) + hight(root.right), 
            Math.max(
                diameterOfBinaryTree(root.left), 
                diameterOfBinaryTree(root.right)
            )
        );
    }
}
```

```java
class Solution {
    // 优美的代码
    private int ans;
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return ans;   
    }
    
    private int depth(TreeNode root) {
        if (root == null)
            return 0;
        int l = depth(root.left);
        int r = depth(root.right);
        ans = Math.max(l + r, ans);
        return Math.max(l, r) + 1;
    }
}
```

### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

Java:

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null)
            return ans;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List<Integer> level = new ArrayList<>();
            int n = queue.size();
            for (int i = 0; i < n; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null)
                    queue.offer(node.left);
                if (node.right != null)
                    queue.offer(node.right);
            }
            ans.add(level);
        }
        return ans;
    }
}
```

### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

Java:

```java
class Solution {
    private TreeNode createBST(int[] arr, int l, int r) {
        if (l > r)
            return null;
        int mid = (l + r) / 2;
        return new TreeNode(arr[mid], createBST(arr, l, mid - 1), createBST(arr, mid + 1, r));
    }

    public TreeNode sortedArrayToBST(int[] nums) {
        return createBST(nums, 0, nums.length - 1);
    }
}
```

### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

Java:

```java
class Solution {
    // 定义
    public boolean isValidBST(TreeNode root) {
        return fun(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    
    private boolean fun(TreeNode root, long min, long max) {
         if (root == null)
            return true;
        if ( root.val >= max || root.val <= min)
            return false;
        return fun(root.left, min, root.val) && fun(root.right, root.val, max);
    }
}
```

```java
class Solution {
    // 中序遍历
    private long pre = Long.MIN_VALUE;
    boolean res = true;
    public boolean isValidBST(TreeNode root) {
        if (root == null)
            return true;
        isValidBST(root.left);
        if (root.val <= pre)
            res = false;
        else 
            pre = root.val;
        isValidBST(root.right);
        return res;
    }
}
```

### [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

Java:

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Deque<TreeNode> q = new LinkedList<>();
        while (root != null || !q.isEmpty()) {
            while (root != null) {
                q.push(root);
                root = root.left;
            }
            root = q.pop();
            if (k == 1) {
                return root.val;
            }
            k--;
            root = root.right;
        }
        return 0;
    }
}
```

### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

Java:

```java
class Solution {
	// dfs
    boolean[] vis = new boolean[105];
    private void dfs(TreeNode r, int dep, List<Integer> ans) {
        if (r == null)
            return;
        if (!vis[dep]) {
            ans.add(r.val);
            vis[dep] = true;
        }
        dfs(r.right, dep + 1, ans);
        dfs(r.left, dep + 1, ans);
    }

    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        dfs(root, 0, ans);
        return ans;
    }
}
```

```java
class Solution {
    // 优美的代码
   private int depth = 0;
   private int max = -1;
   private List<Integer> ans = new ArrayList<>();
   public List<Integer> rightSideView(TreeNode root) {
       if (root == null){
           if (depth == 0){
               return ans;
           }
           return null;
       }
       if (depth > max){
           ans.add(root.val);
           max = depth;
       }
       depth++;
       rightSideView(root.right);
       rightSideView(root.left);
       depth--;
       return ans;
   }
}
```

### [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

Java:

```java
class Solution {
    public void flatten(TreeNode root) {
        TreeNode cur = root;
        while (cur != null) {
            if (cur.left != null) {
                TreeNode next = cur.left;
                TreeNode pre = cur.left;
                while (pre.right != null)
                    pre = pre.right;
                pre.right = cur.right;
                cur.left = null;
                cur.right = next;
            }
            cur = cur.right;
        }
    }
}
```



### [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

Java:

```java
class Solution {
    // 哈希
    HashMap<Integer, Integer> map = new HashMap<>();
    private TreeNode createTree(
        int[] pre, int[] in, 
        int pl, int pr, // 前序
        int il, int ir // 中序
    ) {
        if (pl > pr)
            return null;
        int idx = map.get(pre[pl]);
        return new TreeNode(
            pre[pl],
            createTree(
                pre, in, pl+1, pl+idx-il, il, idx-1
            ),
            createTree(
                pre, in, pl+idx-il+1, pr, idx+1, ir
            )
        );
    }


    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return createTree(
            preorder, inorder, 
            0, inorder.length-1, 
            0, inorder.length-1
        );
    }
}
```

### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

Java:

```java
class Solution {
public:
    int rootSum(TreeNode* root, long targetSum) {
        if (!root) {
            return 0;
        }

        int ret = 0;
        if (root->val == targetSum) {
            ret++;
        } 

        ret += rootSum(root->left, targetSum - root->val);
        ret += rootSum(root->right, targetSum - root->val);
        return ret;
    }

    int pathSum(TreeNode* root, int targetSum) {
        if (!root) {
            return 0;
        }
        
        int ret = rootSum(root, targetSum);
        ret += pathSum(root->left, targetSum);
        ret += pathSum(root->right, targetSum);
        return ret;
    }
};
```

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

Java:

```java
class Solution {

    private TreeNode ans;
    private boolean dfs(TreeNode r, TreeNode p, TreeNode q) {
        if (r == null)
            return false;
        // 左子树是否包含p或q
        boolean lb = dfs(r.left, p, q);  
        // 右子树是否包含p或q
        boolean rb = dfs(r.right, p, q); 
        // 最近公共祖先满足的条件
        if (
            (lb && rb) || (
                (r.val == p.val || r.val == q.val) && 
                (lb || rb)
            )
        )
            ans = r;
        
        return lb || rb || (r.val == p.val || r.val == q.val);
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        dfs(root, p, q);
        return ans;
    }
}
```

### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

Java:

```java
class Solution {
	// dfs
    private int m, n;
    private void dfs(char[][] grid, int x, int y) {
        if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == '0')
            return;
        grid[x][y] = '0';
        dfs(grid, x + 1, y);
        dfs(grid, x - 1, y);
        dfs(grid, x, y + 1);
        dfs(grid, x, y - 1);
    }
    public int numIslands(char[][] grid) {
        int count = 0;

        m = grid.length;
        n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }
}
```

### [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

Java:

```java
class Solution {
    // 多源bfs
    private class Ty {
        int x, y;
        Ty(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    int[] dx = {0,0,1,-1};
    int[] dy = {1,-1,0,0};
    public int orangesRotting(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int d[][] = new int[m][n]; 
        Queue<Ty> q = new LinkedList<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                d[i][j] = Integer.MAX_VALUE;
                if (grid[i][j] == 2) {
                    q.add(new Ty(i, j));
                    d[i][j] = 0;
                }
            }
        }

        int ans = 0;
        while (!q.isEmpty()) {
            Ty o = q.poll();
            ans = Math.max(ans, d[o.x][o.y]);
            for (int i = 0; i < 4; i++) {
                int ddx = o.x + dx[i];
                int ddy = o.y + dy[i];
                if (ddx < 0 || ddy < 0 || ddx >= m || ddy >= n)
                    continue;
                if (grid[ddx][ddy] != 1)
                    continue;
                if (d[o.x][o.y] + 1 < d[ddx][ddy]) {
                    grid[ddx][ddy] = 2;
                    d[ddx][ddy] = d[o.x][o.y] + 1;
                    q.add(new Ty(ddx, ddy));
                }
            }
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) 
                    return -1;
            }
        }
        return ans;
    }
}
```

### [207. 课程表](https://leetcode.cn/problems/course-schedule/)

Java:

```java
class Solution {	
    // dfs拓扑
    private boolean dfs(int[][] g, int[] vis, int u) {
        vis[u] = -1;
        for (int v = 0; v < g.length; v++) if (g[u][v] == 1) {
            if (vis[v] == -1) // 存在回路
                return false;
            else if (vis[v] == 0 && !dfs(g, vis, v))
                return false;
        }
        vis[u] = 1;
        return true;
    }

    private boolean toposort(int[][] g, int[] vis) {
        for (int u = 0; u < g.length; u++) { 
            // 未访问过的节间
            if (vis[u] == 0 && !dfs(g, vis, u))
                return false;
        }
        return true;
    }

    public boolean canFinish(int n, int[][] prerequisites) {
        // 建图
        int[][] g = new int[n][n];
        for (int[] t : prerequisites) {
            g[t[1]][t[0]] = 1;
        }
        //toposort
        int[] vis = new int[n];
        return toposort(g, vis);
    }
}
```

### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

Java:

```java
class Trie {
    // 26叉树和标志位
    private Trie[] childs;
    private boolean isEnd;

    private Trie searchPrefix(String prefix) {
        Trie root = this;
        for (char ch : prefix.toCharArray()) {
            ch -= 'a';
            if (root.childs[ch] == null)
                return null;
            root = root.childs[ch];
        }
        return root;
    }

    public Trie() {
        childs = new Trie[26];
        isEnd = false;
    }
    
    public void insert(String word) {
        Trie root = this;
        for (char ch : word.toCharArray()) {
            ch -= 'a';
            if (root.childs[ch] == null) {
                root.childs[ch] = new Trie();
            }
            root = root.childs[ch];
        }
        root.isEnd = true;
    }
    
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }
}
```

### [46. 全排列](https://leetcode.cn/problems/permutations/)

Java:

```java
class Solution {

    private List<List<Integer>> result = new ArrayList<>();
    private List<Integer> ans = new ArrayList<>();
    
    private void dfs(int n, int dep, boolean[] vis, int[] nums) {
        if (dep >= n) {
            result.add(new ArrayList<>(ans));
            return;
        }
        for (int i = 0; i < n; i++) if (!vis[i]) {
            vis[i] = true;
            ans.add(nums[i]);
            dfs(n, dep + 1, vis, nums);
            ans.remove(ans.size() - 1);
            vis[i] = false;
        }
    }

    public List<List<Integer>> permute(int[] nums) {
        int n = nums.length;
        dfs(n, 0, new boolean[n], nums);
        return result;
    }

}
```

### [78. 子集](https://leetcode.cn/problems/subsets/)

Java:

```java
class Solution {
	// 根据n的二进制表示获取元素
    private List<Integer> subset(int n, int[] nums) {
        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            if (((n >> i) & 1) == 1)
                res.add(nums[i]);
        }
        return res;
    }

    public List<List<Integer>> subsets(int[] nums) {
        int n = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < 1 << n; i++) {
            ans.add(subset(i, nums));
        }
        return ans;
    }
}
```

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

Java:

```java
class Solution {

    public static HashMap<Integer, String> map = new HashMap<>() {
        {
            put(2, "abc");
            put(3, "def");
            put(4, "ghi");
            put(5, "jkl");
            put(6, "mno");
            put(7, "pqrs");
            put(8, "tuv");
            put(9, "wxyz");
       }
    };

    private void dfs(char[] arr, int dep, StringBuffer sb, List<String> ans) {
        if (dep >= arr.length) {
            ans.add(sb.toString());
            return;
        }
		// 获取第dep个数字对应的字母序列
        for (char ch : map.get(arr[dep] - '0').toCharArray()) {
            sb.append(ch);
            dfs(arr, dep + 1, sb, ans);
            sb.deleteCharAt(dep);
        }

    } 

    public List<String> letterCombinations(String digits) {
        List<String> ans = new ArrayList<>();
        if ("".equals(digits))  
            return ans;
        dfs(digits.toCharArray(), 0, new StringBuffer(), ans);
        return ans;
    }
}
```

### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

Java:

```java
class Solution {
    // 搜索 + 剪枝
    private void dfs(int[] arr, int target, List<List<Integer>> res, List<Integer> path, int start) {
        if (0 == target) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = start; i < arr.length; i++) {
            if (target - arr[i] < 0) // 剪枝
                return;
            path.add(arr[i]);
            dfs(arr, target - arr[i], res, path, i);
            path.remove(path.size() - 1);
        }
    }

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(candidates); // 后面大的不用考虑
        dfs(candidates, target, res, new ArrayList<Integer>(), 0);
        return res;
    }
}
```

### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

Java:

```java
class Solution {
	// 二进制 4ms 
    private String get(int n, int len) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < len; i++) {
            if (((n >> i) & 1) == 1)
                sb.append('(');
            else
                sb.append(')');
        }
        return sb.toString();
    }

    private boolean check(int n, int len) {
        int c = 0;
        for (int i = 0; i < len; i++) {
            if (((n >> i) & 1) == 1)
                c++;
            else    
                c--;
            if (c < 0)
                return false;
        }
        return c == 0;
    }

    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        n *= 2;
        for (int i = 0; i < (1 << n); i++) {
            if (check(i, n))
                res.add(get(i, n));
        }
        return res;

    }
}
```

```java
class Solution {

    private void dfs(int l, int r, StringBuffer sb, List<String> res) {
        if (l == 0 && r == 0) {
            res.add(sb.toString());
            return;
        }
        // 还有右括号就放
        if (l > 0) {
            sb.append('(');
            dfs(l - 1, r, sb, res);
            sb.deleteCharAt(sb.length() - 1);
        }
		// 左括号比右括号多就可以放
        if (r > l) {
            sb.append(')');
            dfs(l, r - 1, sb, res);
            sb.deleteCharAt(sb.length() - 1);
        }
    }

    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        dfs(n, n, new StringBuffer(), res);
        return res;    
    }
}
```

### [79. 单词搜索](https://leetcode.cn/problems/word-search/)

Java:

```java
class Solution {
	// dfs 剪枝
    private static final int[] dx = {1,-1,0,0};
    private static final int[] dy = {0,0,1,-1};
    private int m, n;
    private boolean dfs(int x, int y, char[][] board, boolean[][] vis, String word, int idx) {
        if (board[x][y] != word.charAt(idx)) return false;
        if (idx == word.length() - 1) return true;  
        boolean res = false;
        vis[x][y] = true;
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 0 || ny < 0 || nx >= m || ny >= n) continue;
            if (vis[nx][ny]) continue;   
            res |= dfs(nx, ny, board, vis, word, idx + 1);
            if (res) return true;
        }
        vis[x][y] = false;
        return res;
    }

    public boolean exist(char[][] board, String word) {
        m = board.length;
        n = board[0].length;
        boolean[][] vis = new boolean[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(i, j, board, vis, word, 0)) 
                    return true;
            }
        }
        return false;
    }
}
```

### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

Java:

```java
class Solution {
    // dp + dfs
    public List<List<String>> partition(String s) {
        int n = s.length();
        List<List<String>> result = new ArrayList<>();
        // f[i, j] 是否是回文串
        boolean[][] f = new boolean[n][n];
		// 长度为1的都是回文串
        for (int i = 0; i < n; i++) {
            Arrays.fill(f[i], true);
        }
		// i从后往前枚举 前面需要后面已经确认才能得到正确答案
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                f[i][j] = f[i + 1][j - 1] && s.charAt(i) == s.charAt(j);
            }
        }
		// 无情dfs + 回溯
        dfs(s, 0, result, new ArrayList<String>(), f);
        return result;
    }

    private void dfs(String s, int i, List<List<String>> res, List<String> ans, boolean[][] f) {
        if (i == s.length()) {
            res.add(new ArrayList(ans));
            return;
        }
        for (int j = i; j < s.length(); j++) {
            if (f[i][j]) {
                ans.add(s.substring(i, j + 1));
                dfs(s, j + 1, res, ans, f);
                ans.remove(ans.size() - 1);
            }
        }
    }
}
```

### [51. N 皇后](https://leetcode.cn/problems/n-queens/)

Java:

```java
class Solution {

    private List<List<String>> res = new ArrayList<>();

    private List<String> getList(int[] c) {
        int n = c.length;
        List<String> ans = new ArrayList<>();
        char[] row = new char[n];
        Arrays.fill(row, '.');
        for (int i = 0; i < n; i++) {
            row[c[i]] = 'Q';
            ans.add(new String(row));
            row[c[i]] = '.';
        }
        return ans;
    }

    private void dfs(int dep, int[] c, boolean[][] vis) {
        if (dep == c.length) {
            // add
            res.add(getList(c));
            return;
        }

        for (int i = 0; i < c.length; i++) {
            if (vis[0][dep + i] || vis[1][dep - i + c.length] || vis[2][i])
                continue;
            c[dep] = i;
            vis[0][dep + i] = true;
            vis[1][dep - i + c.length] = true;
            vis[2][i] = true;
            dfs(dep + 1, c, vis);
            vis[0][dep + i] = false;
            vis[1][dep - i + c.length] = false;
            vis[2][i] = false;
        }
    }

    public List<List<String>> solveNQueens(int n) {
        dfs(0, new int[n], new boolean[3][n*2]);
        return res;
    }
}
```

[74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

Java:

```java
class Solution {
    // 映射
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int l = 0, r = m * n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (matrix[mid / n][mid % n] == target)
                return true;
            else if (matrix[mid / n][mid % n] < target)
                l = mid + 1;
            else    
                r = mid - 1;
        }
        return false;
    }
}
```

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

Java:

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftIdx = binarySearch(nums, target, true);
        int rightIdx = binarySearch(nums, target, false) - 1;
        if (leftIdx <= rightIdx && 
          rightIdx < nums.length && 
          nums[leftIdx] == target && 
          nums[rightIdx] == target) {
        	return new int[]{leftIdx, rightIdx};
        } 
        return new int[]{-1, -1};
    }

    public int binarySearch(int[] nums, int target, boolean lower) {
        int left = 0, right = nums.length - 1, ans = nums.length;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
}
```

